//! Internal functions used by the derive macro.

use core::marker::PhantomPinned;
use core::mem::MaybeUninit;
use core::pin::Pin;
use core::ptr::drop_in_place;
use std::rc::Rc;

use crate::Header;

/// A trait implemented by all structures using incrstruct. The
/// implementation is auto-generated by the macros.
///
/// Used by auto-generated code. This is not an external API.
pub trait IncrStructInit: Sized {
    type Error;

    /// Initializes all leaf fields, in dependency order. All head
    /// fields have already been initialized, and all tail fields are
    /// uninitialized. When this function returns, all tail fields of
    /// the struct must have been initialized.
    unsafe fn init(this: *mut Self) -> Result<(), Self::Error>;

    /// Drops all head fields, going in normal drop order. It is only
    /// called when all head fields are initialized.
    unsafe fn drop_uninit_in_place(this: &mut MaybeUninit<Self>);

    /// Drops all tail fields starting at `at`, going in normal drop
    /// order. A zero drops all tail fields. It is only called when
    /// the referenced tail fields have been initialized.
    unsafe fn drop_tail_in_place(this: &mut Self, at: usize);

    /// Returns a reference to the incrstruct header. This field
    /// should be last, so it's dropped last.
    fn header<'b>(this: &'b mut Self) -> &'b mut Header;
}

/// Creates a `Box` from the given, partial struct. The function
/// initializes all fields. The input is normally created using
/// `T::new_uninit`.
///
/// Used by auto-generated code.
pub fn new_box<T: IncrStructInit>(v: MaybeUninit<T>) -> Result<Pin<Box<T>>, T::Error> {
    let raw = Box::into_raw(Box::new(v));
    // SAFETY: we keep a pin until the Box is reassembled.
    let _pinned_raw = unsafe { Pin::new_unchecked(&mut *raw) };

    // SAFETY: we have taken ownership of the pointer to uninitialized Box data.
    match unsafe { ensure_init(&mut *raw) } {
        Ok(ptr) => {
            // SAFETY: the data is fully initialized, and Box can take ownership.
            Ok(unsafe { Pin::new_unchecked(Box::from_raw(ptr as *mut _)) })
        }
        Err(err) => {
            // SAFETY: only head data is initialized.
            unsafe {
                T::drop_uninit_in_place(&mut *raw);
                _ = Box::from_raw(raw);
            }
            Err(err)
        }
    }
}

/// Creates a `Rc` from the given, partial struct. The function
/// initializes all fields. The input is normally created using
/// `T::new_uninit`.
///
/// Used by auto-generated code.
pub fn new_rc<T: IncrStructInit>(v: MaybeUninit<T>) -> Result<Pin<Rc<T>>, T::Error> {
    let raw = Rc::into_raw(Rc::new(v)) as *mut _;
    // SAFETY: we keep a pin until the Rc is reassembled.
    let _pinned_raw = unsafe { Pin::new_unchecked(&mut *raw) };

    // SAFETY: we have taken ownership of the pointer to uninitialized Box data.
    match unsafe { ensure_init(&mut *raw) } {
        Ok(ptr) => {
            // SAFETY: the data is fully initialized, and Box can take ownership.
            Ok(unsafe { Pin::new_unchecked(Rc::from_raw(ptr as *mut _)) })
        }
        Err(err) => {
            // SAFETY: only head data is initialized.
            unsafe {
                T::drop_uninit_in_place(&mut *raw);
                _ = Rc::from_raw(raw);
            }
            Err(err)
        }
    }
}

/// Forces initialization of `this`, even if it was previously initialized.
///
/// This is useful when a T has moved, and the self-referencing tail
/// fields must be synchronized.
///
/// The caller is reponsible for keeping `this` pinned.
///
/// # Safety
///
/// This function is always safe to call, but only makes sense to call
/// after you have used an unsafe function to move a pinned value
/// somewhere else.
pub fn force_init<T: IncrStructInit>(this: &mut T) -> Result<(), T::Error> {
    match <T as IncrStructInit>::header(this) {
        Header::Uninited => {}
        // SAFETY: we are now making `this` back into a partially
        // initialized struct, the same as Uninited.
        Header::Inited(_) => unsafe {
            T::drop_tail_in_place(this, 0);
        },
        Header::Initing => panic!("Recursive call to force_init"),
    };

    // SAFETY: tail fields are uninitialized.
    unsafe { do_init(this) }
}

/// Creates a partially initialized struct. The `f` function
/// initializes all head fields, and only the head fields.
///
/// Used by auto-generated code.
///
/// # Safety
///
/// Calling this function yields a value that will not call
/// destructors. Callers must use `drop_uninit` until a successful
/// call to `ensure_init`. After `ensure_init`, the caller owns the
/// `*mut Self`, and normal drop rules apply.
pub unsafe fn new_uninit<T: IncrStructInit, F: FnOnce(&mut T)>(f: F) -> MaybeUninit<T> {
    let mut out = MaybeUninit::<T>::uninit();

    let this = &mut *out.as_mut_ptr();
    core::ptr::write(<T as IncrStructInit>::header(this), Header::Uninited);

    f(this);

    out
}

/// Finalizes a partially initialized struct. The returned reference
/// is guaranteed to be the same as `this`, and is only returned as a
/// type-safety convenience.
///
/// If an error occurs, all tail fields are dropped before the
/// function returns. Thus, it's safe to call `ensure_init` again. The
/// caller is responsible for calling `drop_uninit` if required.
///
/// The caller is responsible for pinning `this`.
///
/// Used by auto-generated code.
///
/// # Safety
///
/// This function assumes head fields are initialized and that tail
/// fields are not .
pub unsafe fn ensure_init<T: IncrStructInit>(
    this: &mut MaybeUninit<T>,
) -> Result<&mut T, T::Error> {
    let r = &mut *this.as_mut_ptr();

    match <T as IncrStructInit>::header(r) {
        Header::Uninited => do_init(r)?,
        _ => panic!("ensure_init called on already initialized struct"),
    };

    Ok(this.assume_init_mut())
}

/// Drops a partially initialized struct. Tail fields are assumed to
/// be uninitialized, while all head fields are assumed to be
/// initialized.
///
/// Used by auto-generated code.
///
/// # Safety
///
/// It only drops head fields. This function panics if the struct is
/// not `Uninited`.
pub unsafe fn drop_uninit_in_place<T: IncrStructInit, F: FnOnce(&mut T)>(
    this: &mut MaybeUninit<T>,
    f: F,
) {
    let r = &mut *this.as_mut_ptr();

    match <T as IncrStructInit>::header(r) {
        Header::Uninited => {
            f(r);

            drop_in_place(<T as IncrStructInit>::header(r));
        }
        Header::Inited(_) => panic!("drop_uninit_in_place on initialized value"),
        Header::Initing => panic!("drop_uninit_in_place during initialization"),
    }
}

/// Performs initialization of tail fields, without sanity checking.
///
/// See [ensure_init] and [force_init].
unsafe fn do_init<T: IncrStructInit>(this: &mut T) -> Result<(), T::Error> {
    *<T as IncrStructInit>::header(this) = Header::Initing;

    // If we panic in the middle of init(), data will
    // leak without being dropped, even if
    // drop_uninit_in_place is invoked later.
    //
    // It seems most things in the Rust standard library
    // are not unwind-safe, e.g. unlocking mutexes on
    // panic.
    //
    // SAFETY: the code above has made the struct partially
    // initialized.

    match T::init(this) {
        Ok(_) => {
            *<T as IncrStructInit>::header(this) = Header::Inited(PhantomPinned);

            Ok(())
        }
        Err(err) => {
            *<T as IncrStructInit>::header(this) = Header::Uninited;

            Err(err)
        }
    }
}
