use core::cell::{Ref, RefCell};
use core::marker::PhantomPinned;
use core::mem::MaybeUninit;
use core::ptr::drop_in_place;
use std::rc::Rc;

#[derive(Clone, Debug)]
pub enum Header {
    Uninited,
    Initing,
    Inited(PhantomPinned),
}

type IncrCell<T> = T;

/// An trait implemented by all structures using incrstruct. The
/// implementation is auto-generated by the macros.
pub trait IncrStructInit: Sized {
    /// Initializes all leaf fields, in dependency order. All head
    /// fields have already been initialized, and all tail fields are
    /// uninitialized. When this function returns, all tail fields of
    /// the struct must have been initialized.
    ///
    /// This is not marked unsafe, because we don't want to allow the
    /// generated `init_field_X` to be unsafe.
    fn init(this: *mut Self);

    unsafe fn drop_tail_in_place(this: &mut Self);

    /// Returns a reference to the incrstruct header. This field
    /// should be last, so it's dropped last.
    fn header<'b>(this: &'b mut Self) -> &'b mut Header;
}

/// Creates a `Box` from the given, partial struct. The function
/// initializes all fields.
///
/// Used by auto-generated code.
fn new_box<T: IncrStructInit>(v: MaybeUninit<T>) -> Box<T> {
    let bx = Box::new(v);
    let raw = Box::into_raw(bx);

    // SAFETY: we have taken ownership of the pointer to uninitialized Box data.
    let ptr = ensure_init(unsafe { &mut *raw });

    // SAFETY: the data is fully initialized, and Box can take ownership.
    unsafe { Box::from_raw(ptr as *mut _) }
}

/// Creates a `Rc` from the given, partial struct. The function
/// initializes all fields.
///
/// Used by auto-generated code.
fn new_rc<T: IncrStructInit>(v: MaybeUninit<T>) -> Rc<T> {
    let rc = Rc::new(v);
    let raw = Rc::into_raw(rc);

    // SAFETY: we have taken ownership of the pointer to
    // uninitialized Rc data. We are the only writers.
    let ptr = ensure_init(unsafe { &mut *(raw as *mut _) }) as *mut _;

    // SAFETY: the data is fully initialized, and Rc can take ownership.
    unsafe { Rc::from_raw(ptr) }
}

/// Creates a partially initialized struct. The `f` function
/// initializes all head fields, and only the head fields.
///
/// Used by auto-generated code.
///
/// # Safety
///
/// Calling this function yields a value that will not call
/// destructors. Callers must use `drop_uninit_in_place` until a
/// successful call to `ensure_init`. After `ensure_init`, the caller
/// owns the `*mut Self`, and normal drop rules apply.
unsafe fn new_uninit<T: IncrStructInit, F: FnOnce(&mut T)>(f: F) -> MaybeUninit<T> {
    let mut out = MaybeUninit::<T>::uninit();

    // SAFETY: we just created the uninitialized value.
    let this = unsafe { &mut *out.as_mut_ptr() };
    unsafe { core::ptr::write(<T as IncrStructInit>::header(this), Header::Uninited) };

    f(this);

    out
}

/// Finalizes a partially initialized struct. The returned reference
/// is guaranteed to be the same as `this`, and is only returned as a
/// type-safety convenience.
///
/// Used by auto-generated code.
fn ensure_init<T: IncrStructInit>(this: &mut MaybeUninit<T>) -> &mut T {
    // SAFETY: we have exclusive access to `this`.
    let r = unsafe { &mut *this.as_mut_ptr() };

    match <T as IncrStructInit>::header(r) {
        Header::Inited(_) => {}
        _ => force_init(r),
    };

    // SAFETY: all fields have been initialized.
    unsafe { this.assume_init_mut() }
}

/// Drops a partially initialized struct. Tail fields are assumed to
/// be uninitialized, while all head fields are assumed to be
/// initialized.
///
/// Used by auto-generated code.
fn drop_uninit_in_place<T: IncrStructInit, F: FnOnce(&mut T)>(mut this: MaybeUninit<T>, f: F) {
    // SAFETY: `this` was moved into here.
    let r = unsafe { &mut *this.as_mut_ptr() };

    match <T as IncrStructInit>::header(r) {
        Header::Uninited => {
            f(r);

            // SAFETY: we only drop head fields, and only once.
            unsafe { drop_in_place(<T as IncrStructInit>::header(r)) };
        }
        Header::Inited(_) => panic!("drop_uninit_in_place on initialized value"),
        Header::Initing => panic!("drop_uninit_in_place during initialization"),
    }
}

/// Forces initialization of `this`, even if it was previously initialized.
///
/// This is useful when a T has moved, and the self-referencing tail
/// fields must be synchronized.
pub fn force_init<T: IncrStructInit>(this: &mut T) {
    match <T as IncrStructInit>::header(this) {
        Header::Uninited => {}
        // SAFETY: we are now making `this` back into a partially
        // initialized struct, the same as Uninited.
        Header::Inited(_) => unsafe {
            T::drop_tail_in_place(this);
        },
        Header::Initing => panic!("Recursive call to force_init"),
    };

    *<T as IncrStructInit>::header(this) = Header::Initing;

    // If we panic in the middle of this code, data will
    // leak without being dropped, even if
    // drop_uninit_in_place is invoked later.
    //
    // It seems most things in the Rust standard library
    // are not unwind-safe, e.g. unlocking mutexes on
    // panic.

    T::init(this);

    *<T as IncrStructInit>::header(this) = Header::Inited(PhantomPinned);
}

pub struct A<'a> {
    pub c: IncrCell<&'a i32>,
    pub b: IncrCell<Ref<'a, i32>>,
    pub a: RefCell<i32>,

    hdr: Header,
}

impl<'a> A<'a> {
    pub fn new_box(a: i32) -> Box<Self> {
        // SAFETY: the callee is aware the struct is partially initialized.
        new_box(unsafe { Self::new_uninit(a) })
    }

    pub fn new_rc(a: i32) -> Rc<Self> {
        // SAFETY: the callee is aware the struct is partially initialized.
        new_rc(unsafe { Self::new_uninit(a) })
    }

    /// See `iterstruct::force_init`.
    pub fn force_init(&mut self) {
        force_init(self);
    }

    /// See `iterstruct::new_uninit`.
    pub unsafe fn new_uninit(a: i32) -> MaybeUninit<Self> {
        new_uninit::<A<'a>, _>(|out| {
            // SAFETY: we only write each field once, so this overwrites
            // uninitialized values.
            unsafe { core::ptr::write(&mut out.a, RefCell::new(a)) };
        })
    }

    /// Drops a value previously created with `new_uninit`.
    #[allow(dead_code)] // To be used later, currently only used in tests.
    fn drop_uninit_in_place(this: MaybeUninit<Self>) {
        drop_uninit_in_place(this, |this| {
            // SAFETY: we only drop head fields, and only once.
            unsafe {
                drop_in_place(&mut this.a);
            };
        });
    }
}

impl<'a> IncrStructInit for A<'a> {
    fn init(this: *mut Self) {
        // SAFETY: `this` was moved into here.
        let r = unsafe { &mut *this };

        // SAFETY: since we only support referencing earlier fields,
        // in a DAG, this always writes to uninitialized space.

        {
            let v = Self::init_field_b(&r.a);
            unsafe { core::ptr::write(&mut r.b as *mut _, v) };
        };
        {
            let v = Self::init_field_c(&r.b);
            unsafe { core::ptr::write(&mut r.c as *mut _, v) };
        };
    }

    /// Drops all tail fields, returning a partially initialized struct.
    unsafe fn drop_tail_in_place(this: &mut Self) {
        // SAFETY: we only drop head fields, and only once.
        drop_in_place(&mut this.c);
        drop_in_place(&mut this.b);
    }

    fn header<'b>(this: &'b mut Self) -> &'b mut Header {
        &mut this.hdr
    }
}

impl<'a> A<'a> {
    fn init_field_b(a: &'a RefCell<i32>) -> Ref<'a, i32> {
        a.borrow()
    }

    fn init_field_c(b: &'a i32) -> &'a i32 {
        b
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn new_uninit_works() {
        let mut a = unsafe { A::new_uninit(42) };
        let aref = ensure_init(&mut a);

        assert_eq!(*aref.a.borrow(), 42);
        assert_eq!(*aref.b, 42);
        assert_eq!(*aref.c, 42);

        unsafe { drop_in_place(aref) };
    }

    #[test]
    fn drop_uninit_in_place_works() {
        let a = unsafe { A::new_uninit(42) };

        assert_eq!(*(unsafe { &*a.as_ptr() }).a.borrow(), 42);

        A::drop_uninit_in_place(a);
    }

    #[test]
    fn new_box_works() {
        let a = A::new_box(42);

        assert_eq!(*a.a.borrow(), 42);
        assert_eq!(*a.b, 42);
        assert_eq!(*a.c, 42);
    }

    #[test]
    fn new_rc_works() {
        let a = A::new_rc(42);

        assert_eq!(*a.a.borrow(), 42);
        assert_eq!(*a.b, 42);
        assert_eq!(*a.c, 42);
    }

    #[test]
    fn force_init_works() {
        let a = A::new_box(42);
        let mut b = *a;

        b.force_init();

        assert_eq!(*b.a.borrow(), 42);
        assert_eq!(*b.b, 42);
        assert_eq!(*b.c, 42);
    }
}
